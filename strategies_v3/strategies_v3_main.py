# üî∏ –ò–º–ø–æ—Ä—Ç—ã –∏ –±–∞–∑–æ–≤–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞
import asyncio
import logging

# üî∏ –ò–º–ø–æ—Ä—Ç –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
from strategies_v3_interface import StrategyInterface

logging.basicConfig(level=logging.INFO)

# üî∏ –•—Ä–∞–Ω–∏–ª–∏—â–∞ –≤ –ø–∞–º—è—Ç–∏
tickers_storage = {}
open_positions = {}
latest_prices = {}
# üî∏ –•—Ä–∞–Ω–∏–ª–∏—â–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
strategies_cache = {}
allowed_symbols = {}

# üî∏ –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–∏–∫–µ—Ä–æ–≤ –∏–∑ –ë–î
async def load_tickers():
    interface = StrategyInterface()
    global tickers_storage
    tickers_storage = await interface.load_tickers()
    logging.info(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ —Ç–∏–∫–µ—Ä–æ–≤: {len(tickers_storage)}")

# üî∏ –ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
async def load_strategies():
    interface = StrategyInterface()
    pg = await interface.get_pg()
    rows = await pg.fetch("""
        SELECT * FROM strategies_v2
        WHERE enabled = true AND archived = false
    """)
    global strategies_cache
    strategies_cache = {row["name"]: dict(row) for row in rows}
    logging.info(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π: {len(strategies_cache)}")

# üî∏ –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–∏–∫–µ—Ä–æ–≤, —Ä–∞–∑—Ä–µ—à—ë–Ω–Ω—ã—Ö –¥–ª—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
async def load_strategy_tickers():
    interface = StrategyInterface()
    pg = await interface.get_pg()

    # üîπ –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–∏–∫–µ—Ä—ã —Å —Ä–∞–∑—Ä–µ—à—ë–Ω–Ω–æ–π —Ç–æ—Ä–≥–æ–≤–ª–µ–π
    ticker_rows = await pg.fetch("""
        SELECT symbol FROM tickers
        WHERE status = 'enabled' AND tradepermission = 'enabled'
    """)
    all_symbols = {row["symbol"] for row in ticker_rows}

    # üîπ –ó–∞–≥—Ä—É–∂–∞–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ —Å use_all_tickers = true
    global allowed_symbols
    allowed_symbols.clear()

    strategy_all_rows = await pg.fetch("""
        SELECT name FROM strategies_v2
        WHERE enabled = true AND archived = false AND use_all_tickers = true
    """)
    for row in strategy_all_rows:
        allowed_symbols[row["name"]] = set(all_symbols)

    # üîπ –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–≤—è–∑–∏ –∏–∑ strategy_tickers_v2 –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
    specific_rows = await pg.fetch("""
        SELECT s.name AS strategy_name, t.symbol
        FROM strategy_tickers_v2 st
        JOIN strategies_v2 s ON s.id = st.strategy_id
        JOIN tickers t ON t.id = st.ticker_id
        WHERE st.enabled = true AND t.status = 'enabled' AND t.tradepermission = 'enabled'
    """)
    for row in specific_rows:
        strategy = row["strategy_name"]
        symbol = row["symbol"]
        allowed_symbols.setdefault(strategy, set()).add(symbol)

    total = sum(len(v) for v in allowed_symbols.values())
    logging.info(f"‚úÖ –†–∞–∑—Ä–µ—à—ë–Ω–Ω—ã–µ —Ç–∏–∫–µ—Ä—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã –¥–ª—è {len(allowed_symbols)} —Å—Ç—Ä–∞—Ç–µ–≥–∏–π, –≤—Å–µ–≥–æ —Å–≤—è–∑–µ–π: {total}")
# üî∏ –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–∏–∫–µ—Ä–æ–≤ –∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π
async def refresh_tickers_periodically():
    while True:
        try:
            await load_tickers()
            await load_strategy_tickers()
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–∏–∫–µ—Ä–æ–≤/—Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π: {e}")
        await asyncio.sleep(120)

# üî∏ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Ü–µ–Ω (–∑–∞–≥–ª—É—à–∫–∞)
async def monitor_prices():
    while True:
        await asyncio.sleep(1)
# üî∏ –°–ª—É—à–∞—Ç–µ–ª—å Redis Stream strategy_tasks
async def listen_strategy_tasks():
    interface = StrategyInterface()
    redis = await interface.get_redis()
    group = "strategy_worker_group"
    consumer = "worker-1"

    try:
        await redis.xgroup_create("strategy_tasks", group, id="0", mkstream=True)
    except Exception:
        pass  # –≥—Ä—É–ø–ø–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç

    while True:
        try:
            messages = await redis.xreadgroup(
                groupname=group,
                consumername=consumer,
                streams={"strategy_tasks": ">"},
                count=10,
                block=500
            )
            for stream_name, msgs in messages:
                for msg_id, msg_data in msgs:
                    task = {k: v for k, v in msg_data.items()}
                    logging.info(f"üì• –ü–æ–ª—É—á–µ–Ω–∞ –∑–∞–¥–∞—á–∞: {task}")
                    await handle_task(task)
                    await redis.xack("strategy_tasks", group, msg_id)
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –∏–∑ Redis Stream: {e}")
            await asyncio.sleep(1)
# üî∏ –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–Ω–æ–π –∑–∞–¥–∞—á–∏ –∏–∑ Redis Stream
async def handle_task(task_data: dict):
    try:
        interface = StrategyInterface()
        strategy_name = task_data["strategy"]
        symbol = task_data["symbol"]
        direction = task_data["direction"]
        log_id_raw = task_data.get("log_id")
        log_id = int(log_id_raw) if log_id_raw is not None else -1

        strategy = strategies_cache.get(strategy_name)
        strategy_id = strategy["id"] if strategy else None

        # üîπ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–∫–µ—Ä–∞
        if symbol not in tickers_storage:
            await interface.log_strategy_action(
                log_id=log_id, strategy_id=strategy_id,
                status="ignored_by_check", note="–¢–∏–∫–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ tickers_storage"
            )
            return

        if tickers_storage[symbol]["tradepermission"] != "enabled":
            await interface.log_strategy_action(
                log_id=log_id, strategy_id=strategy_id,
                status="ignored_by_check", note="–¢–æ—Ä–≥–æ–≤–ª—è —Ç–∏–∫–µ—Ä–æ–º –∑–∞–ø—Ä–µ—â–µ–Ω–∞"
            )
            return

        if symbol not in allowed_symbols.get(strategy_name, set()):
            await interface.log_strategy_action(
                log_id=log_id, strategy_id=strategy_id,
                status="ignored_by_check", note="–¢–∏–∫–µ—Ä –Ω–µ —Ä–∞–∑—Ä–µ—à—ë–Ω –¥–ª—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏"
            )
            return

        if (strategy_name, symbol) in open_positions:
            await interface.log_strategy_action(
                log_id=log_id, strategy_id=strategy_id,
                status="ignored_by_check", note="–ü–æ–∑–∏—Ü–∏—è —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–∞"
            )
            return

        # üîπ –ü–æ–ª—É—á–µ–Ω–∏–µ —Ü–µ–Ω—ã
        entry_price = latest_prices.get(symbol)
        if not entry_price:
            await interface.log_strategy_action(
                log_id=log_id, strategy_id=strategy_id,
                status="error", note="–ù–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω–æ–π —Ü–µ–Ω—ã –≤ Redis"
            )
            return

        # üîπ –í—ã–∑–æ–≤ –ª–æ–≥–∏–∫–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
        mod = __import__(f"strategies_v3.{strategy_name}", fromlist=["on_signal"])
        signal_result = await mod.on_signal(task_data, interface)

        if signal_result.get("action") != "open":
            await interface.log_strategy_action(
                log_id=log_id, strategy_id=strategy_id,
                status="ignored_by_check", note="–°—Ç—Ä–∞—Ç–µ–≥–∏—è –æ—Ç–∫–ª–æ–Ω–∏–ª–∞ —Å–∏–≥–Ω–∞–ª"
            )
            return

        # üîπ –û—Ç–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏
        position_id = await interface.open_position(strategy_name, symbol, direction, entry_price, log_id)

        await interface.log_strategy_action(
            log_id=log_id, strategy_id=strategy_id,
            status="position_opened", position_id=position_id
        )

    except Exception as e:
        await interface.log_strategy_action(
            log_id=log_id,
            strategy_id=strategies_cache.get(task_data.get("strategy"), {}).get("id"),
            status="error",
            note=f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ: {e}"
        )
# üî∏ –ì–ª–∞–≤–Ω–∞—è —Ç–æ—á–∫–∞ –∑–∞–ø—É—Å–∫–∞
async def main():
    logging.info("üöÄ Strategy Worker (v3) –∑–∞–ø—É—â–µ–Ω.")
    await load_tickers()
    await load_strategies()
    await load_strategy_tickers()
    asyncio.create_task(refresh_tickers_periodically())
    asyncio.create_task(monitor_prices())
    await listen_strategy_tasks()

if __name__ == "__main__":
    asyncio.run(main())